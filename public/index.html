<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document AI Web</title>
    <style>
        #content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-top: 20px;
        }

        #text-info {
            width: 45%;
        }

        #canvas-container {
            position: relative;
            width: 50%;
        }

        #canvas, #highlight-canvas {
            max-width: 100%;
            height: auto;
        }

        #highlight-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: auto; /* Habilitar eventos en el canvas */
        }

        .document-info, .invoice-line {
            margin-bottom: 10px;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.3s ease;
        }

        .highlighted {
            background-color: yellow;
        }

        .highlight-box {
            transition: stroke-width 0.3s ease;
        }

        .highlight-box:hover {
            stroke-width: 4px;
        }
    </style>
</head>
<body>
    <h1>Upload a Document</h1>
    <form id="uploadForm" enctype="multipart/form-data">
        <input type="file" name="document" id="document" accept=".pdf,.jpg,.jpeg,.png" required />
        <button type="submit">Upload</button>
    </form>

    <div id="content">
        <div id="text-info">
            <h2>Processed Text</h2>
            <h3>General information</h3>
            <div id="general_info"></div>
            <br />
            <h3>Invoice lines</h3>
            <div id="invoice_lines"></div>
        </div>
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <canvas id="highlight-canvas"></canvas>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script>
        let entities = [];
        let lastHighlightedIndex = null;
        let isDrawing = false;
        let startX = 0;
        let startY = 0;
        let currentRect = {};        

        document.getElementById('uploadForm').addEventListener('submit', async (event) => {
            event.preventDefault();
            const formData = new FormData();
            const fileInput = document.getElementById('document');
            const file = fileInput.files[0];
            formData.append('document', file);

            if (file.type === 'application/pdf') {
                await renderPDF(file);
            } else {
                const imgElement = document.getElementById('canvas');
                imgElement.src = URL.createObjectURL(file);
            }

            const response = await fetch('/upload', {
                method: 'POST',
                body: formData,
            });

            if (response.ok) {
                const result = await response.json();
                entities = result.entities;
                displayRelevantInfo(entities);
                displayInvoiceLines(entities);
                if (file.type === 'application/pdf' || file.type.startsWith('image/')) {
                    drawBoundingBoxes(entities);
                }
            } else {
                document.getElementById('general_info').textContent = 'Error processing document.';
            }
        });

        async function renderPDF(file) {
            const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
            const page = await pdf.getPage(1);
            const scale = 1.5;
            const viewport = page.getViewport({ scale });

            const canvas = document.getElementById('canvas');
            const context = canvas.getContext('2d');
            canvas.width = viewport.width;
            canvas.height = viewport.height;

            const renderContext = {
                canvasContext: context,
                viewport: viewport
            };
            await page.render(renderContext).promise;

            const highlightCanvas = document.getElementById('highlight-canvas');
            highlightCanvas.width = viewport.width;
            highlightCanvas.height = viewport.height;

            drawBoundingBoxes(entities);
        }

        function displayRelevantInfo(parsedData) {
            const resultElement = document.getElementById('general_info');
            resultElement.innerHTML = '';

            parsedData.forEach((item, index) => {
                const type = item.type;
                let mentionText = item.mentionText;

                if (type === 'line_item') {
                    return;
                }

                const itemElement = document.createElement('div');
                itemElement.classList.add('document-info');
                itemElement.setAttribute('data-index', index);

                itemElement.innerHTML = `
                    <strong>${type}:</strong>
                    <input type="text" value="${mentionText}" data-type="${type}" data-index="${index}" class="editable-input">
                    <button onclick="updateValue(${index})">Actualizar</button>
                `;

                itemElement.addEventListener('mouseover', () => highlightBox(index));
                itemElement.addEventListener('mouseout', () => clearPreviousHighlight(false));

                resultElement.appendChild(itemElement);
            });
        }

        function displayInvoiceLines(parsedData) {
            const resultElement = document.getElementById('invoice_lines');
            resultElement.innerHTML = '';

            parsedData.forEach((item, index) => {
                if (item.type === 'line_item') {
                    const description = item.properties.find(prop => prop.type === 'line_item/description')?.mentionText || '';
                    const amount = item.properties.find(prop => prop.type === 'line_item/amount')?.mentionText || '';
                    const quantity = item.properties.find(prop => prop.type === 'line_item/quantity')?.mentionText || '';
                    const unitPrice = item.properties.find(prop => prop.type === 'line_item/unit_price')?.mentionText || '';

                    const lineItemElement = document.createElement('div');
                    lineItemElement.classList.add('invoice-line');
                    lineItemElement.setAttribute('data-index', index);
                    lineItemElement.innerHTML = `
                        <strong>Description:</strong> ${description} <br>
                        <strong>Quantity:</strong> ${quantity} <br>
                        <strong>Unit Price:</strong> ${unitPrice} <br>
                        <strong>Amount:</strong> ${amount} <br>
                        <hr>
                    `;

                    lineItemElement.addEventListener('mouseover', () => highlightBox(index));
                    lineItemElement.addEventListener('mouseout', () => clearPreviousHighlight(false));

                    resultElement.appendChild(lineItemElement);
                }
            });
        }

        function drawBoundingBoxes(entities) {
            const canvas = document.getElementById('highlight-canvas');
            const context = canvas.getContext('2d');

            context.clearRect(0, 0, canvas.width, canvas.height);

            entities.forEach((entity, index) => {
                if (entity.pageAnchor && entity.pageAnchor.pageRefs) {
                    entity.pageAnchor.pageRefs.forEach(pageRef => {
                        if (pageRef.boundingPoly && pageRef.boundingPoly.normalizedVertices) {
                            const vertices = pageRef.boundingPoly.normalizedVertices;
                            const x0 = vertices[0].x * canvas.width;
                            const y0 = vertices[0].y * canvas.height;
                            const x1 = vertices[2].x * canvas.width;
                            const y1 = vertices[2].y * canvas.height;

                            context.beginPath();
                            context.rect(x0, y0, x1 - x0, y1 - y0);
                            context.lineWidth = 2;
                            context.strokeStyle = 'red';
                            context.stroke();

                            entity.boundingBox = { x0, y0, x1, y1 };
                        }
                    });
                }
            });

            canvas.addEventListener('mousedown', (event) => {
                removeHighlightText();
                clearPreviousHighlight(true);
                lastHighlightedIndex = null;

                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clickX = (event.clientX - rect.left) * scaleX;
                const clickY = (event.clientY - rect.top) * scaleY;

                let clickedOnExistingBox = false;

                entities.forEach((entity, index) => {
                    const { x0, y0, x1, y1 } = entity.boundingBox || {};
                    if (x0 && y0 && x1 && y1) {
                        if (clickX >= x0 && clickX <= x1 && clickY >= y0 && clickY <= y1) {
                            clickedOnExistingBox = true;

                            highlightText(index);
                            highlightBox(index);
                            lastHighlightedIndex = index;
                        }
                    }
                });

                if (!clickedOnExistingBox) {
                    startDrawing(event, scaleX, scaleY);
                }
            });
        }

        function highlightBox(index) {
            const canvas = document.getElementById('highlight-canvas');
            const context = canvas.getContext('2d');
            const entity = entities[index];

            clearPreviousHighlight(false);

            if (entity.boundingBox) {
                context.beginPath();
                context.rect(entity.boundingBox.x0, entity.boundingBox.y0, entity.boundingBox.x1 - entity.boundingBox.x0, entity.boundingBox.y1 - entity.boundingBox.y0);
                context.lineWidth = 4;
                context.strokeStyle = 'blue';
                context.stroke();
            }
        }

        function clearPreviousHighlight(fullClear) {
            const canvas = document.getElementById('highlight-canvas');
            const context = canvas.getContext('2d');

            context.clearRect(0, 0, canvas.width, canvas.height);

            entities.forEach((entity) => {
                if (entity.boundingBox) {
                    context.beginPath();
                    context.rect(entity.boundingBox.x0, entity.boundingBox.y0, entity.boundingBox.x1 - entity.boundingBox.x0, entity.boundingBox.y1 - entity.boundingBox.y0);
                    context.lineWidth = 2;
                    context.strokeStyle = 'red';
                    context.stroke();
                }
            });

            if (fullClear && lastHighlightedIndex !== null) {
                highlightBox(lastHighlightedIndex);
            }
        }

        function highlightText(index) {
            const elements = document.querySelectorAll(`[data-index='${index}']`);
            elements.forEach(el => el.classList.add('highlighted'));
        }

        function removeHighlightText() {
            const elements = document.querySelectorAll('.highlighted');
            elements.forEach(el => el.classList.remove('highlighted'));
        }

        function updateValue(index) {
            const inputElement = document.querySelector(`input[data-index='${index}']`);
            const newValue = inputElement.value;
            const type = inputElement.getAttribute('data-type');

            console.log(`Tipo: ${type}, Nuevo valor: ${newValue}`);
        }

        document.getElementById('highlight-canvas').addEventListener('mousemove', drawRect);
        document.getElementById('highlight-canvas').addEventListener('mouseup', finishDrawing);

        function startDrawing(event, scaleX, scaleY) {
            const canvas = document.getElementById('highlight-canvas');
            const rect = canvas.getBoundingClientRect();

            startX = (event.clientX - rect.left) * scaleX;
            startY = (event.clientY - rect.top) * scaleY;
            isDrawing = true;
        }

        function drawRect(event) {
            if (!isDrawing) return;

            const canvas = document.getElementById('highlight-canvas');
            const context = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;

            const width = mouseX - startX;
            const height = mouseY - startY;

            clearPreviousHighlight(false);

            context.beginPath();
            context.rect(startX, startY, width, height);
            context.lineWidth = 2;
            context.strokeStyle = 'green';
            context.stroke();

            currentRect = { startX, startY, width, height };
        }

        function finishDrawing(event) {
            if (!isDrawing) return;
            isDrawing = false;

            const canvas = document.getElementById('highlight-canvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;

            const distanceX = Math.abs(mouseX - startX);
            const distanceY = Math.abs(mouseY - startY);

            const threshold = 5; // Umbral de 5 píxeles

            if (distanceX < threshold && distanceY < threshold) {
                // No crear recuadro si el mouseup es muy cercano al mousedown
                clearPreviousHighlight(false);
                return;
            }

            const value = prompt('Introduce el valor para el nuevo item:');
            const type = prompt('Introduce el tipo de dato (e.g., invoice_id, total_amount):');

            if (value && type) {
                console.log(`Nuevo item - Tipo: ${type}, Valor: ${value}, Rectángulo:`, currentRect);
            }
        }
        
    </script>
</body>
</html>
